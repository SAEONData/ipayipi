% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/z_sub_sf_dta_wr.r
\name{sf_dta_wr}
\alias{sf_dta_wr}
\title{Writes data to file}
\usage{
sf_dta_wr(
  dta_room = NULL,
  dta = NULL,
  tn = NULL,
  sfc = NULL,
  overwrite = TRUE,
  rit = NULL,
  ri = NULL,
  chunk_i = NULL,
  rechunk = FALSE,
  buff_period = "10 years",
  i_zeros = 5,
  verbose = TRUE,
  xtra_v = FALSE,
  ...
)
}
\arguments{
\item{dta_room}{File path where the data will be saved and/or is chunked and indexed.}

\item{dta}{Data to be saved to the \code{dta_room}. Must be a 'data.table' object. Not a list.}

\item{tn}{Name of the data table to be saved. The tables data time-series qualities must be consistent with ipayipi's 'continuous', 'event_based', or 'mixed' series qualities.
_Time-series properties:
Time-series properties are not required. If not provided this will be extracted from data summary information, or via \code{ipayipi::record_interval_eval()}.}

\item{rit}{The record interval type: 'continuous', 'mixed', or 'event_based'.}

\item{ri}{The record interval of the data. A string that will be parsed to \code{ipayipi::sts_interval_name()}. This is used to evaluate the integrity of data chunks time-series consistency; missing date-time values will be filled in as NA values. This applies to mixed and continuous data streams, not event-based where there is no consistent record interval. If the record interval is not provided the function will attempt to define this. If this fails the function will use a default chunking index of two years.}

\item{chunk_i}{The chunking interval. Must be a string representing a time period. The string is standardised by \code{ipayipi::sts_interval_name()}. If no chunk interval is provided the function will estimate an appropriate chunking interval based on the record interval.}

\item{rechunk}{Logical. If TRUE chunked data will be 'rechunked' if necessary. Rechunking is done when \code{chunk_i} is forced to change.}

\item{buff_period}{See \code{ipayipi::sf_dta_chunkr()}.}

\item{i_zeros}{Used to name chunked files; the number of leading zeros to include before a chunk number index.}

\item{verbose}{Logical. Whether or not to report messages and progress.}

\item{cores}{Number of cores to farm processing off to. This assists with increasing the speed of read-write capabilities of data chunks.}
}
\value{
Logical indicating whether data has been saved.
}
\description{
Chunks data if the data.table has a 'date_time' column. Data without a 'date_time' column are saved in RDS format.
}
\details{
This function is an internal function called by others in the pipeline. Its main funciton is to standardise how data is chunked and maintain time-series data integrity. Chunking is done per a 'chunking index' that seperates data chunks by a date floor and ceiling. The index number serves as the identifier for a particular chunk. In addition to the chunk table index the overall min and max date-time of the data series is provided in an index list.
}
\author{
Paul J Gordijn
}
\keyword{big}
\keyword{chunking;}
\keyword{data}
\keyword{data;}
\keyword{indexing;}
